<!-- Mainaging your Current server -->
<section id="manage"<title>Managing your Current Server</title>
<section id="manageintro"><title>Introduction</title>
<para>
Management and maintenance of Current has changed dramatically from the 1.4.x
series to the 1.5.x series.  This portion of the guide will give you the
instructions you need to get your 1.5.x devel server (or later, a 1.6.x 
production server) up and running and serving packages.  Please read this
section carefully, as there is very little that has not changed since 1.4.x.
</para>
</section>
<section id="database"><title>Setting up your database</title>
<para>
The database backend is now a critical part of a functioning Current server.
Without this backend, you won't be able to server any packages, or even
register your clients.  Setting up the database is not difficult, but care
must be taken to not only ensure it's done correctly, but that it's done in a
way which won't compromise security.
</para>
<section id="postgres"><title>The PostgreSQL Backend</title>
<para>
There are two parts to setting up the PostgreSQL backend; first you have to
set up the PostgreSQL server itself to accept connections properly, then
you have to set up the actual database instance your Current server will use.
We'll address them in that order.
</para>
<para>
In order to set up the daemon, you have to first have an established 
<filename>/var/lib/pgsql/data</filename> directory.  This is done by simply
starting the PostgreSQL daemon and immediately stopping it.  Then, you
have to configure the daemon to accept network (TCP/IP) connections.  This is
done by editing two files in the <filename>/var/lib/pgsql/data</filename>
directory, <filename>pg_hba.conf</filename> and 
<filename>postmaster.opts.default</filename>.
</para>
<para>
The <filename>pg_hba.conf</filename> file configures the method(s) used
to authenticate connections to the PostgreSQL service; for Current to work,
we must allow host-based authentication, which is what is used for TCP/IP
connections.  The simplest way of doing this is to add a line to the
end of this file that reads:
<screen>
host    all     127.0.0.1   255.255.255.255     password
</screen>
This allowes host-based connections over TCP/IP from the local host only 
(the loopback adapter, specifically) to all databases with a valid password
supplied.  For more details on what the fields in this line mean, please see
the PostgreSQL documentation.
</para>
<para>
The next file, <filename>postmaster.opts.default</filename>, simply tells the 
startup script what options to pass to the postmaster daemon when the 
PostgreSQL service is started.  Please be very careful to modify the
<filename>postmaster.opts.default</filename> file, even if there isn't one in
existence already - the <filename>postmaster.opts</filename> file simply
records what options the daemon was started with the last time it was started,
it does not control the options.
</para>
<para>
If you have any preexisting options in this file, you should keep them.  You
will have to add a <quote>-i</quote> to this file if it's not already there to
allow TCP/IP connections to the server.
</para>
<para>
Once you've modified those files, you can re-start the PosrgreSQL service and
create the user that the Current server will use to connect to the database.
This user and password must be the same username and password that appear in
your <filename>current.conf</filename> file.  The easiest way to create this
user account is to run the <command>createuser</command> script with the
<quote>-P</quote> option.  Please note that you must use a capital "P" - 
the lowercase "p" is a different option and will cause unexpected behavior.
For more information on creating PostgreSQL users, please see the PostgreSQL
documentation.
</para>
<para>Now that we've allowed TCP/IP connections and created our user, we need
to create the database and tables that Current will use.  First, you need to
create and empty database with the <quote>createdb</quote> command provided
by the PostgreSQL package.  Once the empty database has been created, you will 
create the actual tables that Current will use.  This step has been
simplified for you; all you need to do is run the <command>cinstall initdb</command>
command and the tables will be created automatically.  IF you receive any error
messages, they should be somewhat explicit about what went wrong.  If you're
unable to correct the error, please ask on the mailing list.
</para>
</section>
<section id="pysqlite"><title>The PySQLite Backend</title>
<para>
This section will be fleshed out after Hunter has finished the development of
this backend.
</para>
</section>
</section> <!-- end of database section -->
<section id="channelcreate"><title>Channel Creation and Population</title>
<para>
The way you manage and control your channels has also changed significantly -
as mentioned previously, there is no channel configuration information in the
<filename>current.conf</filename> config file anymore.  Any information that is
there is ignored.  So now you're probably asking me, "If it's ignored, how the
heck to I create a channel?"  This section is going to answer that question
for you, so read on.
</para>
<para>We'll assume you've gone thorugh the database creation process above and
that there were no errors reported.  The first thing to do is to start the 
Apache httpd daemon.  The management interface talks to the server the same way
up2date does; this is a major departure from the way server management was
done in 1.4.x and previous releases.  The developers believe that this change
will greatly enhance the usability and future expandability of Current; we'd
really like to hear feedback from users about the usability of this new
management method.
</para>
<section id="createchan"><title>cadmin create_channel</title>
<para>
There are three commands you will need to use to set up a channel in Current.
The first, <command>cadmin create_channel</command>, is what actually creates
the channel definition.  There are six options available for this command:
</para>
<glosslist>
<glossentry id="name"><glossterm>--name (-n)</glossterm>
<glossdef>
<para>This option specifies the "name" of the channel; the name is used
only for human consumption and is not critical for server operations.  The
name provided must be a valid directory name for the server; i.e. it can
only contain characters that would be valid in a filename, and cannot
contain any escaped characters such as a space.  Each channel is required to 
have a name attribute associated with it.
</para>
</glossdef>
</glossentry>
<glossentry id="label"><glossterm>--label (-l)</glossterm>
<glossdef>
<para>The label is the internal name of the channel used by the server and the
clients that communicate with it.  You will need to remember the channel label
as it is required for other management commands.  Each channel is required to
have a label attribute associated with it.
</para>
</glossdef>
</glossentry>
<glossentry id="arch"><glossterm>--arch (-a)</glossterm>
<glossdef>
<para>The arch is the architecture that this channel will serve.  It is usually
the lowest level compatible architecture; i.e. i386 versus i686.  This is a
required option.
</para>
</glossdef>
</glossentry>
<glossentry id="release"><glossterm>--release (-r)</glossterm>
<glossdef>
<para>The release attribute is the release level of the channel being served;
for a Red Hat Linux 7.2 tree, the release would be "7.2".  This is a required
option.
</para>
</glossdef>
</glossentry>
<glossentry id="description"><glossterm>--description (-d)</glossterm>
<glossdef>
<para>This is a description of the channel that is presented to the user in
the client GUI; it is purely for human consumption and is not used in any way
in the actual management of the server.  This option is not required.
</para>
</glossdef>
</glossentry>
<glossentry id="parent"><glossterm>--parent (-p)</glossterm>
<glossdef>
<para>
This denotes the label of the parent channel of the channel you are creating.  
As of versions 1.5.x and 1.6.x, this option is ignored in operations as we 
do not yet support sub-channels.  Use of this option may cause unexpected 
behavior of the server; it is here for future compatibility purposes only.
In future versions, use of this option will override the arch and release
options (if they are provided).
</para>
</glossdef>
</glossentry>
</glosslist>
<para>
An example channel definition command would be:
<screen>
# cadmin create_channel --name "Red Hat 7.2" --label rhl7.2 --arch i386 \
    --release 7.2 --description "Red Hat Linux version 7.2"
</screen>
The command will output a message telling you if it succeeded or failed, and 
if the latter, why (we hope).  If the command fails for unobvious reasons,
please submit a bug report.
</para>
</section>
<section id="chanadddir"><title>add_dir</title>
<para>
The second command you will need is <command>cadmin add_dir</command>.  This
command takes three options:
</para>
<glosslist>
<glossentry id="addlabel"><glossterm>--label (-l)</glossterm>
<glossdef>
<para>
This is the channel label, as above.  A label is required.
</para>
</glossdef>
</glossentry>
<glossentry id="bindir"><glossterm>--bin-dir (-b)</glossterm>
<glossdef>
<para>The --bin-dir option specifies a directory of binary (as opposed to
source) RPMS that should be associated with this channel.  This option is
not required (you can specify only source directories if you wish), and can be
repeated for multiple binary directories.
</para>
</glossdef>
</glossentry>
<glossentry id="srcdir"><glossterm>--src-dir (-s)</glossterm>
<glossdef>
<para>The --src-dir option specifies a directory of source (as opposed to
binary) RPMS that should be associated with this channel.  This option is
not required (you can specify only binary directories if you wish), and can be
repeated for multiple source directories.
</para>
</glossdef>
</glossentry>
</glosslist>
<para>
The <command>cadmin add_dir</command> command can be issued multiple times
with one directory specified per command, one with all channel directories
specified at the same time, or any combination thereof.  Please note: the
<command>cadmin</command> suite of commands can be run on a machine 
different from the actual Apache / PostgreSQL / Current server machine,
but all directory paths must be valid on that server machine.
</para>
<para>
This cannot be emphasized emough: all directories must be 
<emphasis role="bold">server</emphasis> directories, not necessarily
directories on the machine <command>cadmin</command> is being run on.
</para>
</section>
<section id="scanchan"><title>scan_channel</title>
<para>
The third command you will need to become familiar with is the
<command>cadmin scan_channel</command> command.  This command only takes a
single option, the <quote>--label</quote> option as above.  You can specify
multiple --label options with this command.  This command is what tells the
server to do the bulk of the setup work; it looks at the channel configuration,
reads through the RPMS in the directories specified by the <command>cadmin
add_dir</command> command, and imports the required information into the 
database.  This is analogous to the old (1.4.2 and previous)
<command>cadmin create</command> command.  Please note that this command may
take some time to return; author testing of this command has shown it can take
up to 7 or 10 minutes to scan an entire Red Hat Linux 7.3 tree with source and
binary RPMs.
</para>
</section>
</section>
</section> <!-- closes section id="manage" -->
